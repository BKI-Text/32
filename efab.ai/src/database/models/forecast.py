"""Forecast Model for Beverly Knits AI Supply Chain Planner"""

from sqlalchemy import Column, String, Numeric, Date, Float, Text, Index
from decimal import Decimal
from datetime import date

from .base import BaseModel

class ForecastModel(BaseModel):
    """Forecast database model"""
    __tablename__ = "forecasts"
    
    # Core forecast fields
    sku_id = Column(String, nullable=False, index=True)
    forecast_qty = Column(Numeric(12, 2), nullable=False)
    unit = Column(String(20), nullable=False, default="units")
    forecast_date = Column(Date, nullable=False, index=True)
    
    # Forecast metadata
    source = Column(String(50), nullable=False, index=True)  # sales_order, prod_plan, projection, sales_history
    confidence_score = Column(Float, nullable=False, default=0.5)
    notes = Column(Text, nullable=True)
    
    # Optional ML model information
    model_used = Column(String(50), nullable=True)
    model_version = Column(String(20), nullable=True)
    upper_bound = Column(Numeric(12, 2), nullable=True)
    lower_bound = Column(Numeric(12, 2), nullable=True)
    
    # Tracking fields
    created_by = Column(String, nullable=True)
    is_active = Column(String, nullable=False, default=True)
    
    # Indexes
    __table_args__ = (
        Index('idx_forecast_sku_date', 'sku_id', 'forecast_date'),
        Index('idx_forecast_date_source', 'forecast_date', 'source'),
        Index('idx_forecast_confidence', 'confidence_score'),
        Index('idx_forecast_active', 'is_active'),
    )
    
    def __repr__(self):
        return f"<ForecastModel(sku_id={self.sku_id}, date={self.forecast_date}, qty={self.forecast_qty})>"
    
    def to_domain_entity(self):
        """Convert to domain entity"""
        from ...core.domain.entities import Forecast, ForecastSource
        from ...core.domain.value_objects import SkuId, Quantity
        
        return Forecast(
            sku_id=SkuId(value=self.sku_id),
            forecast_qty=Quantity(amount=self.forecast_qty, unit=self.unit),
            forecast_date=self.forecast_date,
            source=ForecastSource(self.source),
            confidence_score=self.confidence_score,
            notes=self.notes,
            created_at=self.created_at
        )
    
    @classmethod
    def from_domain_entity(cls, forecast):
        """Create from domain entity"""
        return cls(
            sku_id=forecast.sku_id.value,
            forecast_qty=forecast.forecast_qty.amount,
            unit=forecast.forecast_qty.unit,
            forecast_date=forecast.forecast_date,
            source=forecast.source.value,
            confidence_score=forecast.confidence_score,
            notes=forecast.notes,
            created_at=forecast.created_at
        )
    
    def is_high_confidence(self, threshold: float = 0.8) -> bool:
        """Check if forecast has high confidence"""
        return self.confidence_score >= threshold
    
    def is_low_confidence(self, threshold: float = 0.5) -> bool:
        """Check if forecast has low confidence"""
        return self.confidence_score < threshold
    
    def is_recent(self, days: int = 30) -> bool:
        """Check if forecast is recent (within specified days)"""
        from datetime import datetime, timedelta
        cutoff_date = datetime.now().date() - timedelta(days=days)
        return self.created_at.date() >= cutoff_date
    
    def is_future_forecast(self) -> bool:
        """Check if forecast is for a future date"""
        return self.forecast_date > date.today()
    
    def is_past_forecast(self) -> bool:
        """Check if forecast is for a past date"""
        return self.forecast_date < date.today()
    
    def days_until_forecast_date(self) -> int:
        """Calculate days until forecast date"""
        today = date.today()
        if self.forecast_date <= today:
            return 0
        return (self.forecast_date - today).days
    
    def days_since_forecast_date(self) -> int:
        """Calculate days since forecast date"""
        today = date.today()
        if self.forecast_date >= today:
            return 0
        return (today - self.forecast_date).days
    
    def get_forecast_age_days(self) -> int:
        """Get age of forecast in days"""
        today = date.today()
        return (today - self.created_at.date()).days
    
    def is_ml_forecast(self) -> bool:
        """Check if forecast was generated by ML model"""
        return self.model_used is not None
    
    def get_confidence_level(self) -> str:
        """Get confidence level as string"""
        if self.confidence_score >= 0.8:
            return "high"
        elif self.confidence_score >= 0.6:
            return "medium"
        else:
            return "low"
    
    def has_confidence_bounds(self) -> bool:
        """Check if forecast has upper and lower bounds"""
        return self.upper_bound is not None and self.lower_bound is not None
    
    def get_confidence_interval_width(self) -> Decimal:
        """Get width of confidence interval"""
        if not self.has_confidence_bounds():
            return Decimal('0')
        return self.upper_bound - self.lower_bound
    
    def is_within_bounds(self, actual_value: Decimal) -> bool:
        """Check if actual value is within confidence bounds"""
        if not self.has_confidence_bounds():
            return True  # No bounds to check
        return self.lower_bound <= actual_value <= self.upper_bound
    
    def calculate_accuracy(self, actual_value: Decimal) -> float:
        """Calculate forecast accuracy vs actual value"""
        if self.forecast_qty == 0:
            return 0.0
        
        error = abs(actual_value - self.forecast_qty)
        return 1.0 - (float(error) / float(self.forecast_qty))
    
    def calculate_absolute_error(self, actual_value: Decimal) -> Decimal:
        """Calculate absolute error vs actual value"""
        return abs(actual_value - self.forecast_qty)
    
    def calculate_percentage_error(self, actual_value: Decimal) -> float:
        """Calculate percentage error vs actual value"""
        if actual_value == 0:
            return 0.0
        
        error = abs(actual_value - self.forecast_qty)
        return float(error / actual_value) * 100
    
    def update_confidence_score(self, new_score: float):
        """Update confidence score"""
        self.confidence_score = max(0.0, min(1.0, new_score))
    
    def update_forecast_qty(self, new_qty: Decimal):
        """Update forecast quantity"""
        self.forecast_qty = max(Decimal('0'), new_qty)
    
    def add_confidence_bounds(self, lower: Decimal, upper: Decimal):
        """Add confidence bounds to forecast"""
        self.lower_bound = lower
        self.upper_bound = upper
    
    def deactivate(self):
        """Deactivate forecast"""
        self.is_active = False
    
    def activate(self):
        """Activate forecast"""
        self.is_active = True
    
    def get_forecast_summary(self) -> dict:
        """Get summary information about this forecast"""
        return {
            "sku_id": self.sku_id,
            "forecast_qty": float(self.forecast_qty),
            "unit": self.unit,
            "forecast_date": self.forecast_date.isoformat(),
            "source": self.source,
            "confidence_score": self.confidence_score,
            "confidence_level": self.get_confidence_level(),
            "model_used": self.model_used,
            "is_ml_forecast": self.is_ml_forecast(),
            "has_bounds": self.has_confidence_bounds(),
            "days_until_forecast": self.days_until_forecast_date(),
            "forecast_age_days": self.get_forecast_age_days(),
            "is_active": self.is_active
        }
    
    def validate_forecast(self) -> list:
        """Validate forecast and return list of issues"""
        issues = []
        
        if self.forecast_qty < 0:
            issues.append("Forecast quantity cannot be negative")
        
        if not (0 <= self.confidence_score <= 1):
            issues.append("Confidence score must be between 0 and 1")
        
        if self.source not in ['sales_order', 'prod_plan', 'projection', 'sales_history']:
            issues.append("Invalid forecast source")
        
        if not self.sku_id:
            issues.append("SKU ID is required")
        
        if not self.forecast_date:
            issues.append("Forecast date is required")
        
        if self.has_confidence_bounds() and self.lower_bound > self.upper_bound:
            issues.append("Lower bound cannot be greater than upper bound")
        
        return issues