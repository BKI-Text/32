# Claude.code Ultra-Comprehensive Codebase Forensics Prompt

**For use with Claude.code in Cursor IDE with MCP tools**

Please execute an exhaustive forensic-level codebase analysis using the full capabilities of Claude.code intelligence, Cursor IDE's semantic understanding, and coordinated MCP tool execution:

## Maximum Depth Analysis Pipeline

### Forensic-Level MCP Tool Orchestration
```python
# Ultra-comprehensive analysis using all available MCP tools
forensic_analysis_engine = {
    "filesystem_forensics": mcp_filesystem.forensic_deep_scan(),
    "code_archaeology": mcp_git.historical_forensics(),
    "dependency_genealogy": mcp_dependencies.deep_relationship_analysis(),
    "execution_pathology": mcp_tracer.exhaustive_execution_mapping(),
    "memory_forensics": mcp_memory.deep_usage_analysis(),
    "security_penetration": mcp_security.comprehensive_vulnerability_analysis(),
    "performance_forensics": mcp_profiler.exhaustive_performance_analysis(),
    "data_lineage_mapping": mcp_data_analyzer.complete_data_flow_forensics()
}
```

## 1. ARCHITECTURAL FORENSICS ENGINE

### Deep System Topology Analysis
```python
def execute_architectural_forensics():
    """Exhaustive architectural analysis using Claude.code intelligence"""
    
    # Multi-dimensional architectural analysis
    architectural_forensics = {
        "layer_decomposition": analyze_architectural_layers(),
        "component_interdependencies": map_deep_component_relationships(),
        "communication_protocol_analysis": analyze_all_communication_patterns(),
        "data_transformation_pipelines": trace_complete_data_transformations(),
        "infrastructure_topology": map_complete_infrastructure_dependencies(),
        "deployment_orchestration": analyze_deployment_complexity(),
        "scaling_architecture": assess_horizontal_vertical_scaling_patterns(),
        "fault_tolerance_patterns": identify_resilience_mechanisms()
    }
    
    # Generate architectural insights using AI
    architectural_intelligence = cursor_ai.deep_architectural_synthesis(
        architectural_forensics,
        generate_recommendations=True,
        identify_anti_patterns=True,
        suggest_optimizations=True
    )
    
    return architectural_intelligence
```

### Infrastructure Dependency Forensics
```python
def infrastructure_dependency_analysis():
    """Complete infrastructure and external dependency forensics"""
    
    infrastructure_forensics = {
        "cloud_service_mapping": map_all_cloud_dependencies(),
        "third_party_api_analysis": analyze_all_external_integrations(),
        "database_ecosystem": map_complete_data_ecosystem(),
        "message_queue_topology": analyze_async_communication_patterns(),
        "cdn_and_caching_layers": map_content_delivery_infrastructure(),
        "monitoring_observability": catalog_monitoring_infrastructure(),
        "backup_disaster_recovery": analyze_resilience_infrastructure(),
        "security_infrastructure": map_security_service_dependencies()
    }
    
    return infrastructure_forensics
```

## 2. CODE STRUCTURE FORENSICS ENGINE

### Forensic Code Organization Analysis
```python
def execute_code_structure_forensics():
    """Exhaustive code structure and organization forensics"""
    
    structure_forensics = {
        "directory_hierarchy_analysis": mcp_filesystem.hierarchical_analysis(),
        "module_cohesion_coupling": analyze_module_relationships_deeply(),
        "class_relationship_mapping": map_complete_class_hierarchies(),
        "interface_contract_analysis": analyze_all_interface_definitions(),
        "configuration_ecosystem": map_complete_configuration_management(),
        "entry_point_execution_flows": trace_all_application_entry_points(),
        "circular_dependency_detection": find_all_circular_dependencies(),
        "dead_code_identification": identify_all_unreachable_code()
    }
    
    # AI-powered pattern recognition
    pattern_intelligence = cursor_ai.identify_complex_patterns([
        "architectural_patterns",
        "design_patterns", 
        "anti_patterns",
        "code_smells",
        "architectural_violations",
        "coupling_hotspots"
    ])
    
    return {**structure_forensics, **pattern_intelligence}
```

### Module Dependency Genealogy
```python
def analyze_dependency_genealogy():
    """Complete dependency relationship forensics"""
    
    dependency_forensics = {
        "import_relationship_graph": build_complete_import_graph(),
        "dependency_strength_analysis": measure_coupling_strength(),
        "transitive_dependency_mapping": map_transitive_dependencies(),
        "version_compatibility_matrix": analyze_version_dependencies(),
        "security_vulnerability_inheritance": map_security_risks_through_deps(),
        "performance_impact_through_deps": analyze_performance_dependency_costs(),
        "licensing_compliance_mapping": map_license_compatibility(),
        "update_impact_analysis": assess_dependency_update_risks()
    }
    
    return dependency_forensics
```

## 3. FUNCTIONAL BEHAVIOR FORENSICS

### Complete Feature Ecosystem Analysis
```python
def analyze_functional_ecosystem():
    """Exhaustive functional behavior and feature analysis"""
    
    functional_forensics = {
        "feature_discovery": mcp_feature_analyzer.exhaustive_feature_catalog(),
        "user_journey_mapping": trace_complete_user_workflows(),
        "business_logic_decomposition": map_all_business_rules_and_logic(),
        "api_behavior_profiling": analyze_complete_api_ecosystem(),
        "data_processing_pipelines": map_all_data_transformations(),
        "event_system_analysis": analyze_complete_event_architecture(),
        "state_management_patterns": map_application_state_handling(),
        "error_handling_workflows": analyze_complete_error_management()
    }
    
    # AI-powered functional analysis
    functional_intelligence = cursor_ai.analyze_functional_complexity([
        "feature_interaction_complexity",
        "workflow_optimization_opportunities",
        "business_logic_consolidation_potential",
        "api_design_assessment",
        "data_flow_optimization",
        "event_system_efficiency"
    ])
    
    return {**functional_forensics, **functional_intelligence}
```

## 4. TECHNICAL IMPLEMENTATION FORENSICS

### Algorithm & Performance Deep Analysis
```python
def execute_algorithm_forensics():
    """Exhaustive algorithm and performance forensics"""
    
    algorithm_forensics = {
        "algorithmic_complexity_analysis": analyze_all_algorithm_complexity(),
        "performance_hotspot_identification": identify_all_performance_bottlenecks(),
        "memory_usage_patterns": analyze_complete_memory_usage(),
        "io_operation_analysis": map_all_io_operations_and_efficiency(),
        "concurrency_pattern_analysis": analyze_threading_and_async_patterns(),
        "caching_strategy_assessment": evaluate_all_caching_implementations(),
        "database_query_optimization": analyze_all_database_interactions(),
        "network_communication_efficiency": assess_all_network_operations()
    }
    
    # Performance optimization intelligence
    optimization_intelligence = cursor_ai.generate_optimization_strategy(
        algorithm_forensics,
        performance_targets=define_performance_targets(),
        scalability_requirements=assess_scalability_needs()
    )
    
    return {**algorithm_forensics, **optimization_intelligence}
```

### Security Implementation Forensics
```python
def execute_security_forensics():
    """Comprehensive security implementation analysis"""
    
    security_forensics = {
        "authentication_flow_analysis": map_complete_auth_flows(),
        "authorization_matrix_mapping": create_complete_permission_matrix(),
        "input_validation_coverage": assess_all_input_validation(),
        "vulnerability_surface_analysis": map_complete_attack_surface(),
        "encryption_implementation_audit": analyze_all_encryption_usage(),
        "session_management_analysis": assess_session_security(),
        "api_security_assessment": analyze_api_security_implementation(),
        "data_protection_compliance": assess_data_privacy_implementation()
    }
    
    # AI-powered security assessment
    security_intelligence = cursor_ai.comprehensive_security_analysis(
        security_forensics,
        threat_modeling=True,
        compliance_assessment=True,
        penetration_testing_insights=True
    )
    
    return {**security_forensics, **security_intelligence}
```

## 5. OPERATIONAL FORENSICS ENGINE

### Deployment & Infrastructure Forensics
```python
def analyze_operational_forensics():
    """Complete operational and deployment forensics"""
    
    operational_forensics = {
        "build_process_analysis": analyze_complete_build_pipeline(),
        "deployment_orchestration": map_deployment_complexity(),
        "environment_configuration_matrix": analyze_environment_differences(),
        "monitoring_observability_coverage": assess_monitoring_completeness(),
        "logging_strategy_analysis": analyze_logging_implementation(),
        "backup_recovery_procedures": assess_disaster_recovery_readiness(),
        "scalability_infrastructure": analyze_scaling_capabilities(),
        "cost_optimization_opportunities": identify_infrastructure_cost_optimization()
    }
    
    return operational_forensics
```

## MCP Tool Forensic Coordination

### Ultra-Comprehensive Tool Orchestration
```python
class ForensicAnalysisOrchestrator:
    def __init__(self):
        self.mcp_tools = initialize_all_mcp_tools()
        self.cursor_ai = initialize_cursor_intelligence()
        self.analysis_depth = "MAXIMUM"
        
    async def execute_forensic_analysis(self):
        """Execute ultra-comprehensive forensic analysis"""
        
        # Phase 1: Multi-dimensional discovery
        discovery_results = await asyncio.gather([
            self.architectural_forensics(),
            self.structural_forensics(),
            self.functional_forensics(),
            self.technical_forensics(),
            self.security_forensics(),
            self.operational_forensics(),
            self.performance_forensics(),
            self.quality_forensics()
        ])
        
        # Phase 2: Cross-dimensional analysis
        cross_analysis = self.execute_cross_dimensional_analysis(discovery_results)
        
        # Phase 3: AI-powered synthesis
        forensic_intelligence = self.cursor_ai.synthesize_forensic_insights(
            discovery_results + [cross_analysis]
        )
        
        # Phase 4: Actionable intelligence generation
        actionable_insights = self.generate_actionable_intelligence(forensic_intelligence)
        
        return actionable_insights
```

### Real-Time Forensic Processing
```python
def continuous_forensic_analysis():
    """Establish continuous forensic monitoring"""
    
    forensic_monitoring = {
        "code_change_impact_analysis": monitor_code_changes(),
        "performance_regression_detection": monitor_performance_degradation(),
        "security_posture_monitoring": monitor_security_changes(),
        "dependency_vulnerability_tracking": monitor_dependency_security(),
        "architectural_drift_detection": monitor_architectural_changes(),
        "quality_degradation_alerts": monitor_code_quality_changes()
    }
    
    return forensic_monitoring
```

## Ultra-Detailed Output Generation

### Forensic Intelligence Report
```markdown
# Ultra-Comprehensive Codebase Forensic Analysis

## Executive Intelligence Summary
- System Complexity Index: [Calculated multi-dimensional complexity score]
- Security Posture Grade: [Comprehensive security assessment]
- Performance Efficiency Rating: [Complete performance analysis]
- Maintainability Coefficient: [Long-term maintainability prediction]
- Architectural Maturity Level: [Architectural sophistication assessment]
- Technical Debt Severity: [Quantified technical debt analysis]

## Architectural Forensics
### System Topology Deep Analysis
[Multi-layered architectural visualization with intelligence annotations]

### Component Interdependency Matrix
[Comprehensive component relationship mapping with coupling analysis]

### Infrastructure Dependency Graph
[Complete infrastructure and external dependency visualization]

## Code Structure Forensics
### Module Relationship Genealogy
[Deep module relationship analysis with coupling strength indicators]

### Class Hierarchy Forensics
[Complete inheritance and composition relationship mapping]

### Design Pattern Implementation Analysis
[Identified patterns with implementation quality assessment]

## Functional Behavior Forensics
### Feature Ecosystem Mapping
[Comprehensive feature catalog with interaction analysis]

### Business Logic Complexity Analysis
[Business rule implementation assessment with optimization opportunities]

### Data Flow Forensics
[Complete data transformation and flow analysis]

## Technical Implementation Forensics
### Algorithm Complexity Assessment
[Detailed algorithmic complexity analysis with optimization recommendations]

### Performance Hotspot Analysis
[Complete performance bottleneck identification with impact assessment]

### Security Implementation Audit
[Comprehensive security implementation analysis with vulnerability assessment]

## Operational Forensics
### Deployment Complexity Analysis
[Complete deployment pipeline analysis with optimization opportunities]

### Infrastructure Optimization Opportunities
[Infrastructure efficiency assessment with cost optimization recommendations]

## Cross-Dimensional Analysis
### System Interaction Patterns
[Multi-dimensional system behavior analysis]

### Risk Assessment Matrix
[Comprehensive risk analysis across all dimensions]

### Optimization Opportunity Prioritization
[Prioritized improvement recommendations with impact analysis]
```

### Continuous Intelligence System
```python
# Establish ongoing forensic intelligence
continuous_intelligence = {
    "real_time_code_quality_monitoring": True,
    "automated_security_posture_assessment": True,
    "performance_regression_prediction": True,
    "architectural_drift_detection": True,
    "dependency_risk_monitoring": True,
    "optimization_opportunity_identification": True
}
```

Execute this ultra-comprehensive forensic analysis using maximum capabilities of Claude.code intelligence, Cursor IDE's semantic understanding, and coordinated MCP tool execution to generate complete forensic-level codebase intelligence.